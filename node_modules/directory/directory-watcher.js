var _events = require('events'),
    _sys = require('sys'),
    _system = require('system'),
    _fs = require('fs'),
    _path = require('path');

var defaultInterval = 250;

function getKeyForPath(path) {
    // this is not really correct, but it should work for the majority of cases.
    return process.platform === 'win32' ? path.toLowerCase() : path;
}

var DirectoryWatcher = function (path) {
    _events.EventEmitter.call(this);
    this.watcher_ = null;
    this.path_ = path;
    this.fileInfo_ = {};
    this.fileInfoCount_ = 0;
    this.modifiedFileInfo_ = {};
};

_sys.inherits(DirectoryWatcher, _events.EventEmitter);

_system.extend(DirectoryWatcher.prototype,
    {
        getPath:function () {
            return this.path_;
        },
        addFiles:function (files) {
            this.throwIfClosed_();

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = getKeyForPath(file), fileInfo = this.fileInfo_[key];
                if (!fileInfo) {
                    fileInfo = {
                        name:file,
                        lastModified:new Date(),
                        exists:null
                    };
                    this.fileInfo_[key] = fileInfo;

                    // track count of files
                    this.fileInfoCount_++;
                }
            }, this);

            if (!this.watcher_ && this.fileInfoCount_) {
                var self = this;
                try {
                    this.watcher_ = _fs.watch(this.path_, function () {
                        // TODO: Optimize for when we DO get passed a filename!!
                        self.update_();
                    });
                } catch (e) {
                    // TODO: Support recursive update
                }
            }
        },
        removeFiles:function (files) {
            this.throwIfClosed_();

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = getKeyForPath(file);
                if (this.hasOwnProperty(key)) {
                    delete this.fileInfo_[key];
                    delete this.modifiedFileInfo_[key];

                    this.fileInfoCount_--;
                }
            }, this);

            if (!this.fileInfoCount_) {
                this.closeWatcher_();
            }
        },
        getFiles:function () {
            return Object.getOwnPropertyNames(this.fileInfo_).map(
                function (propertyName) {
                    return this.fileInfo_[propertyName].name;
                },
                this);
        },
        close:function () {
            if (!this.isClosed_) {
                this.closeWatcher_();
                this.cancelUpdate_();
                this.fileInfo_ = null;
                this.fileInfoCount_ = 0;
                this.isClosed_ = true;
            }
        },
        update_:function () {
            if (!this.isUpdating_) {
                this.isUpdating_ = true;

                // throttle...
                var self = this;
                setTimeout(function () {
                    self.isUpdating_ = false;
                    self.updateCore_();
                }, defaultInterval);
            }
        },
        updateCore_:function () {
            var files = this.getFiles(), fileCount = files.length, self = this;

            // cancel any running update
            this.cancelUpdate_();

            // track completion
            function complete() {
                if (!cancellationToken.isCancelled && !--fileCount) {
                    self.notify_();
                }
            }

            // create a cancellation token
            var cancellationToken = this.updateToken_ = {
                isCancelled:false
            };

            // update status
            for (var i = 0, n = files.length; i < n && !cancellationToken.isCancelled; i++) {
                this.updateFile_(files[i], cancellationToken, complete);
            }
        },
        notify_:function () {
            // anything actually changed?
            var modifiedFileInfo = this.modifiedFileInfo_,
                modifiedFiles = Object.getOwnPropertyNames(modifiedFileInfo).map(function (propertyName) {
                    return modifiedFileInfo[propertyName].name;
                }, this);

            if (modifiedFiles.length) {
                // clear tracked modifications
                this.modifiedFileInfo_ = {};

                // notify!!
                this.emit('change', modifiedFiles);
            }
        },
        updateFile_:function (file, cancellationToken, callback) {
            var fullPath = _path.join(this.path_, file), self = this;
            _fs.stat(fullPath, function (err, stats) {
                if (!cancellationToken.isCancelled && !err) {
                    // get fileInfo, it may have been removed whilst getting info
                    var key = getKeyForPath(file), fileInfo = self.fileInfo_[key], lastModified = stats.mtime;

                    // check for modification
                    if (fileInfo && lastModified.valueOf() > fileInfo.lastModified.valueOf()) {
                        fileInfo.lastModified = lastModified;

                        // record the file as modified
                        self.modifiedFileInfo_[key] = fileInfo;
                    }
                }

                // done
                callback();
            });
        },
        closeWatcher_:function () {
            if (this.watcher_) {
                this.watcher_.close();
                this.watcher_ = null;
            }
        },
        cancelUpdate_:function () {
            if (this.updateToken_) {
                this.updateToken_.isCancelled = true;
                this.updateToken_ = null;
            }
        },
        throwIfClosed_:function () {
            if (this.isClosed_) {
                throw new Error("Invalid operations, directory watcher has been closed.");
            }
        }
    });

module.exports = DirectoryWatcher;

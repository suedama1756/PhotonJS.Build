var _events = require('events'),
    _sys = require('sys'),
    _system = require('system'),
    _fs = require('fs'),
    _path = require('path'),
    _fwatchUtility = require('./fwatch-utility.js')

var defaultInterval = 250;

function DirectoryWatcher(path) {
    _events.EventEmitter.call(this);
    this.watcher_ = null;
    this.path_ = path;
    this.fileInfo_ = {};
    this.fileInfoCount_ = 0;
    this.modifiedFileInfo_ = {};
}
;

_sys.inherits(DirectoryWatcher, _events.EventEmitter);

_system.extend(DirectoryWatcher.prototype,
    {
        getPath:function () {
            return this.path_;
        },
        addFiles:function (files) {
            this.throwIfClosed_();

            var lastModified = new Date(), fileInfo = this.fileInfo_;

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = _fwatchUtility.getKeyForPath(file);
                if (!fileInfo[key]) {
                    fileInfo[key] = {
                        name:file, lastModified:lastModified, exists:null
                    };
                    this.fileInfoCount_++;
                }
            }, this);

            if (!this.watcher_ && this.fileInfoCount_) {
                this.activate_();
            }
        },
        activate_:function () {
            this.closeWatcher_();

            try {
                this.watcher_ = _fs.watch(this.path_, this.update_.bind(this)); // TODO: Optimize for when we DO get passed a filename!!
            } catch (e) {
                var current = this.path_, parent = _path.dirname(current);
                while (parent !== current) {
                    if (_fs.existsSync(parent)) {
                        this.watcher_ = _fs.watch(parent, function () {
                            if (_fs.existsSync(current)) {
                                this.activate_();
                            }
                        }.bind(this));
                        break;
                    }
                    current = parent;
                    parent = _path.dirname(current);
                }
            }

            if (!this.watcher_) {
                // notify (don't throw as we are asynchronous in nature)
                this.on('error', _system.string.format("Could not bind watcher to path {0}.", this.path_));
            } else {
                // listen for errors, this occurs when the watched file is deleted...
                this.watcher_.on('error', this.activate_.bind(this));
            }
        },
        removeFiles:function (files) {
            this.throwIfClosed_();

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = _fwatchUtility.getKeyForPath(file);
                if (this.hasOwnProperty(key)) {
                    delete this.fileInfo_[key];
                    delete this.modifiedFileInfo_[key];

                    this.fileInfoCount_--;
                }
            }, this);

            if (!this.fileInfoCount_) {
                this.closeWatcher_();
            }
        },
        getFiles:function () {
            return Object.getOwnPropertyNames(this.fileInfo_).map(
                function (propertyName) {
                    return this.fileInfo_[propertyName].name;
                },
                this);
        },
        close:function () {
            if (!this.isClosed_) {
                this.closeWatcher_();
                this.cancelUpdate_();
                this.fileInfo_ = null;
                this.fileInfoCount_ = 0;
                this.isClosed_ = true;
            }
        },
        update_:function () {
            if (!this.isUpdating_) {
                this.isUpdating_ = true;

                // throttle...
                setTimeout(function () {
                    this.isUpdating_ = false;
                    this.updateCore_();
                }.bind(this), defaultInterval);
            }
        },
        updateCore_:function () {
            var files = this.getFiles(), fileCount = files.length;

            // cancel any running update
            this.cancelUpdate_();

            // track completion
            var complete = function () {
                if (!cancellationToken.isCancelled && !--fileCount) {
                    this.notify_();
                }
            }.bind(this);

            // create a cancellation token
            var cancellationToken = this.updateToken_ = {
                isCancelled:false
            };

            // update status
            for (var i = 0, n = files.length; i < n && !cancellationToken.isCancelled; i++) {
                this.updateFile_(files[i], cancellationToken, complete);
            }
        },
        notify_:function () {
            // anything actually changed?
            var modifiedFileInfo = this.modifiedFileInfo_,
                modifiedFiles = Object.getOwnPropertyNames(modifiedFileInfo).map(function (propertyName) {
                    return modifiedFileInfo[propertyName].name;
                }, this);

            if (modifiedFiles.length) {
                // clear tracked modifications
                this.modifiedFileInfo_ = {};

                // notify!!
                this.emit('change', modifiedFiles);
            }
        },
        updateFile_:function (file, cancellationToken, callback) {
            var fullPath = _path.join(this.path_, file);
            _fs.stat(fullPath, function (err, stats) {
                if (!cancellationToken.isCancelled) {
                    var key = _fwatchUtility.getKeyForPath(file), fileInfo = this.fileInfo_[key];
                    if (!err) {
                        // get fileInfo, it may have been removed whilst getting info
                        var lastModified = stats.mtime;

                        // check for modification
                        if (fileInfo && lastModified.valueOf() > fileInfo.lastModified.valueOf()) {
                            fileInfo.lastModified = lastModified;
                            fileInfo.exists = true;

                            // record the file as modified
                            this.modifiedFileInfo_[key] = fileInfo;
                        }
                    } else if (!_fs.existsSync(fullPath)) {
                        //  file doesn't exist
                        fileInfo.exists = false;

                        // record the modification
                        this.modifiedFileInfo_[key] = fileInfo;
                    }
                }

                // done
                callback();
            }.bind(this));
        },
        closeWatcher_:function () {
            if (this.watcher_) {
                this.watcher_.close();
                this.watcher_ = null;
            }
        },
        cancelUpdate_:function () {
            if (this.updateToken_) {
                this.updateToken_.isCancelled = true;
                this.updateToken_ = null;
            }
        },
        throwIfClosed_:function () {
            if (this.isClosed_) {
                throw new Error("Invalid operations, directory watcher has been closed.");
            }
        }
    });

module.exports = DirectoryWatcher;
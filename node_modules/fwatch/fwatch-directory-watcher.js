var _fs = require('fs'),
    _path = require('path'),
    _system = require('system'),
    _events = require('events'),
    _sys = require('sys');

var INTERVAL_DEFAULT = 250;

function DirectoryWatcher(path) {
    _events.EventEmitter.call(this);

    this.path_ = _path.normalize(_path.resolve(path));

    this.watcher_ = _fs.watch(this.path_,
        this.fsChangedHandler_ = this.fsChanged_.bind(this));

    this.fileWatchers = {};

    this.watcher_.on('error', function () {
        if (!_fs.existsSync(this.path_)) {
            // TODO: If root watch for re-attachment
            this.watcher_.close();
            this.watcher_ = null;
        }
    }.bind(this));

    this.beginUpdate_();
    this.children_ = {};
}

_sys.inherits(DirectoryWatcher, _events.EventEmitter);

_system.extend(
    DirectoryWatcher.prototype,
    /**
     * @lends DirectoryWatcher.prototype
     */
    {
        getPath:function () {
            return this.path_;
        },
        fsChanged_:function () {
            if (!this.isUpdating_) {
                this.isUpdating_ = true;

                // throttle...
                setTimeout(function () {
                    this.isUpdating_ = false;
                    this.beginUpdate_();
                }.bind(this), INTERVAL_DEFAULT);
            }
        },
        updateChildDirectory_:function (fileName, oldInfo, newInfo) {
            var child;
            if (oldInfo && oldInfo.isDirectory && (!newInfo || !newInfo.isDirectory)) {
                child = this.children_[fileName];
                if (child) {
                    child.close();
                    delete this.children_[fileName];
                }
            } else if (newInfo && newInfo.isDirectory && (!oldInfo || !oldInfo.isDirectory)) {
                this.children_[fileName] = child = new DirectoryWatcher(_path.join(this.path_, fileName));
                child.on('change', function (created, deleted, modified) {
                    this.emit('change', created, deleted, modified);
                }.bind(this));
            }
        },
        endUpdate_:function (newFileInfo) {
            var oldFileInfo = this.fileInfo_;
            if (oldFileInfo) {
                var deleted = [], created = [], modified = [];

                _system.object.forEachOwnPropertyAndValue(oldFileInfo, function (fileName, oldInfo) {
                    var newInfo = newFileInfo[fileName];
                    if (newInfo) {
                        if ((newInfo.mtime - oldInfo.mtime) || (newInfo.size - oldInfo.size) || (newInfo.isDirectory != oldInfo.isDirectory)) {
                            modified.push(fileName);
                        }

                    } else {
                        deleted.push(fileName);
                    }

                    this.updateChildDirectory_(fileName, oldInfo, newInfo)
                }, this);


                _system.object.forEachOwnPropertyAndValue(newFileInfo, function (fileName, newInfo) {
                    var oldInfo = oldFileInfo[fileName];
                    if (!oldInfo) {
                        created.push(fileName);
                    }

                    this.updateChildDirectory_(fileName, oldInfo, newInfo);
                }, this);

                // clear dead watchers
                deleted.forEach(function (fileName) {
                    this.unwatchFile_(fileName);
                }, this);

                this.emit('change',
                    created.map(this.mapFullPath_, this),
                    deleted.map(this.mapFullPath_, this),
                    modified.map(this.mapFullPath_, this));
            } else {
                _system.object.forEachOwnPropertyAndValue(newFileInfo, function (fileName, newInfo) {
                    this.updateChildDirectory_(fileName, null, newInfo);
                }, this);
            }

            this.fileInfo_ = newFileInfo;
            this.updateToken_ = null;
        },
        beginUpdate_:function () {
            // cancel outstanding update
            if (this.updateToken_) {
                this.updateToken_.isCancelled = true;
                this.updateToken_ = null;
            }

            // update
            this.update_(this.updateToken_ = {
                isCancelled:false
            });
        },
        close:function () {
            if (!this.isClosed_) {
                this.isClosed_ = true;

                if (this.watcher_) {
                    this.watcher_.close();
                    this.watcher_ = null;
                }
            }
        },
        mapFullPath_:function (fileName) {
            return _path.join(this.path_, fileName);
        },
        watchFile_:function (fileName) {
            if (!this.fileWatchers[fileName]) {
                var watcher = this.fileWatchers[fileName] = _fs.watch(this.mapFullPath_(fileName),
                    this.fsChangedHandler_);
                watcher.on('error', function () {
                    this.unwatchFile_(fileName);
                }.bind(this));
            }
        },
        unwatchFile_:function (fileName) {
            var watcher = this.fileWatchers[fileName];
            if (watcher) {
                watcher.close();
                delete this.fileWatchers[fileName];
            }
        },
        update_:function (cancellationToken) {
            var basePath = this.path_,
                fileInfo = {},
                completed = this.endUpdate_.bind(this);

            _fs.readdir(this.path_, function (readDirErr, files) {
                if (!readDirErr) {
                    var fileCount = files.length;
                    if (fileCount) {
                        for (var i = 0, n = fileCount; i < n && !cancellationToken.isCancelled; i++) {
                            this.watchFile_(files[i]);
                            (function (file) {
                                _fs.stat(_path.join(basePath, file), function (statErr, stat) {
                                    if (!statErr) {
                                        fileInfo[file] = {
                                            mtime:stat.mtime, isDirectory:stat.isDirectory(), size:stat.size
                                        }
                                    }
                                    if (!--fileCount) {
                                        completed(fileInfo);
                                    }
                                });
                            })(files[i]);
                        }
                    }
                    else {
                        completed(fileInfo);
                    }
                } else if (!cancellationToken.isCancelled) {
                    completed(fileInfo);
                }
            }.bind(this));
        }
    });

module.exports = DirectoryWatcher;
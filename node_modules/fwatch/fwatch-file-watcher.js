var _events = require('events'),
    _sys = require('sys'),
    _system = require('system'),
    _path = require('path'),
    _fs = require('fs');

var INTERVAL_DEFAULT = 250;

function getKeyForPath(path) {
    // this is not really correct, but it should work for the majority of cases.
    return process.platform === 'win32' ? path.toLowerCase() : path;
}

function resolveFullPath(basePath, fileName) {
    return _path.normalize(_path.resolve(basePath, fileName));
}

function DirectoryFileWatcher(path) {
    _events.EventEmitter.call(this);
    this.watcher_ = null;
    this.path_ = path;
    this.fileInfo_ = {};
    this.fileInfoCount_ = 0;
    this.modifiedFileInfo_ = {};
}

_sys.inherits(DirectoryFileWatcher, _events.EventEmitter);

_system.extend(DirectoryFileWatcher.prototype,
    {
        getPath:function () {
            return this.path_;
        },
        getWatchedFileCount: function() {
            return this.fileInfoCount_;
        },
        watchFiles:function (files) {
            this.throwIfClosed_();

            var lastModified = new Date(), fileInfo = this.fileInfo_;

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = getKeyForPath(file);
                if (!fileInfo[key]) {
                    fileInfo[key] = {
                        name:file, lastModified:lastModified, status:null
                    };
                    this.fileInfoCount_++;
                }
            }, this);

            if (!this.watcher_ && this.fileInfoCount_) {
                this.activate_();
            }
        },
        activate_:function () {
            this.closeWatcher_();
            if (!this.fileInfoCount_) {
                return;
            }

            try {
                this.watcher_ = _fs.watch(this.path_, this.beginUpdate_.bind(this)); // TODO: Optimize for when we DO get passed a filename!!
            } catch (e) {
                var current = this.path_, parent = _path.dirname(current);
                while (parent !== current) {
                    if (_fs.existsSync(parent)) {
                        this.watcher_ = _fs.watch(parent, function () {
                            if (_fs.existsSync(current)) {
                                this.activate_();
                            }
                        }.bind(this));
                        break;
                    }
                    current = parent;
                    parent = _path.dirname(current);
                }
            }

            if (!this.watcher_) {
                // notify (don't throw as we are asynchronous in nature)
                this.emit('error', new Error(_system.string.format("Could not bind watcher to path '{0}'.", this.path_)));
            } else {
                // listen for errors, this occurs when the watched file is deleted...
                this.watcher_.on('error', this.activate_.bind(this));
            }
        },
        unwatchFiles:function (files) {
            this.throwIfClosed_();

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = getKeyForPath(file);
                if (this.hasOwnProperty(key)) {
                    delete this.fileInfo_[key];
                    delete this.modifiedFileInfo_[key];

                    this.fileInfoCount_--;
                }
            }, this);

            if (!this.fileInfoCount_) {
                this.closeWatcher_();
            }
        },
        getFiles:function () {
            return Object.getOwnPropertyNames(this.fileInfo_).map(
                function (propertyName) {
                    return this.fileInfo_[propertyName].name;
                },
                this);
        },
        close:function () {
            if (!this.isClosed_) {
                this.closeWatcher_();
                this.cancelUpdate_();
                this.fileInfo_ = null;
                this.fileInfoCount_ = 0;
                this.isClosed_ = true;
            }
        },
        beginUpdate_:function () {
            if (!this.isUpdating_) {
                this.isUpdating_ = true;

                // throttle...
                setTimeout(function () {
                    this.isUpdating_ = false;
                    this.updateCore_();
                }.bind(this), INTERVAL_DEFAULT);
            }
        },
        updateCore_:function () {
            var files = this.getFiles(), fileCount = files.length;

            // cancel any running update
            this.cancelUpdate_();

            // track completion
            var complete = function () {
                if (!cancellationToken.isCancelled && !--fileCount) {
                    this.notify_();
                }
            }.bind(this);

            // create a cancellation token
            var cancellationToken = this.updateToken_ = {
                isCancelled:false
            };

            // update status
            for (var i = 0, n = files.length; i < n && !cancellationToken.isCancelled; i++) {
                this.updateFile_(files[i], cancellationToken, complete);
            }
        },
        notify_:function () {
            // anything actually changed?
            var modifiedFileInfo = this.modifiedFileInfo_,
                modifiedFiles = Object.getOwnPropertyNames(modifiedFileInfo).map(function (propertyName) {
                    return modifiedFileInfo[propertyName].name;
                }, this);

            if (modifiedFiles.length) {
                // clear tracked modifications
                this.modifiedFileInfo_ = {};

                // notify!!
                this.emit('change', this, modifiedFiles);
            }
        },
        updateFile_:function (file, cancellationToken, callback) {
            var fullPath = _path.join(this.path_, file);
            _fs.stat(fullPath, function (err, stats) {
                if (!cancellationToken.isCancelled) {
                    var key = getKeyForPath(file), fileInfo = this.fileInfo_[key];
                    if (!err) {
                        // get fileInfo, it may have been removed whilst getting info
                        var lastModified = stats.mtime;

                        // check for modification
                        if (fileInfo && lastModified.valueOf() > fileInfo.lastModified.valueOf()) {
                            fileInfo.lastModified = lastModified;
                            fileInfo.status = true;

                            // record the file as modified
                            this.modifiedFileInfo_[key] = fileInfo;
                        }
                    } else if (!_fs.existsSync(fullPath)) {
                        //  file doesn't exist
                        fileInfo.status = false;

                        // record the modification, right now we don' care about deletes, consumer
                        // should determine this for themselves.
                        this.modifiedFileInfo_[key] = fileInfo;
                    }
                }

                // done
                callback();
            }.bind(this));
        },
        closeWatcher_:function () {
            if (this.watcher_) {
                this.watcher_.close();
                this.watcher_ = null;
            }
        },
        cancelUpdate_:function () {
            if (this.updateToken_) {
                this.updateToken_.isCancelled = true;
                this.updateToken_ = null;
            }
        },
        throwIfClosed_:function () {
            if (this.isClosed_) {
                throw new Error("Invalid operations, directory watcher has been closed.");
            }
        }
    });

function FileWatcher(baseDirectory) {
    _events.EventEmitter.call(this);

    this.directoryWatchers_ = {};
    this.baseDirectory_ = baseDirectory;
    this.changeHandler_ = this.fsChanged_.bind(this);
}

_sys.inherits(FileWatcher, _events.EventEmitter);

_system.extend(
    FileWatcher.prototype,
    {
        forEachFile_:function (files, callback) {
            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                file = resolveFullPath(this.baseDirectory_, file);

                var directory = _path.dirname(file),
                    directoryKey = getKeyForPath(directory);

                callback(file, directory, directoryKey,
                    this.directoryWatchers_[directoryKey]);
            }, this);
        },
        watchFiles:function (files) {
            this.forEachFile_(files, function(file, directory, directoryKey, watcher) {
                if (!watcher) {
                    watcher = this.directoryWatchers_[directoryKey] =
                        new DirectoryFileWatcher(directory);
                    watcher.on('change', this.changeHandler_);
                }

                watcher.watchFiles(_path.basename(file));
            }.bind(this));
        },
        unwatchFiles:function (files) {
            this.forEachFile_(files, function(file, directory, directoryKey, watcher) {
                if (watcher) {
                    watcher.unwatchFiles(file);
                    if (watcher.getWatchedFileCount() == 0) {
                        delete this.directoryWatchers_[directoryKey];
                    }
                }
            }.bind(this));
        },
        close : function() {
            if (!this.isClosed_) {
                this.isClosed_ = true;

                _system.object.forEachOwnPropertyAndValue(function(propertyName, watcher, obj) {
                    watcher.close();
                    delete obj[propertyName];
                }, this);
            }
        },
        throwIfClosed_:function () {
            if (this.isClosed_) {
                throw new Error("Invalid operations, directory watcher has been closed.");
            }
        },
        fsChanged_:function (sender, fileNames) {
            this.emit("change", fileNames.map(function(fileName) {
                return _path.join(sender.getPath(), fileName)
            }));
        }
    });

module.exports = FileWatcher;
var _system = require('system'),
    _fs = require('fs'),
    _path = require('path'),
    _events = require('events'),
    _sys = require('sys'),
    _vm = require('vm'),
    _directory = require('directory');

var defaultInterval = 250,
    minimumInterval = 100;

function resolveFullPath(basePath, fileName) {
    return _path.normalize(_path.resolve(basePath, fileName));
};

function getKeyForPath(path) {
    // this is not really correct, but it should work for the majority of cases.
    return process.platform === 'win32' ? path.toLowerCase() : path;
}

function ModuleWatcher(moduleFile, options) {
    // initialize as event emitter
    _events.EventEmitter.call(this);

    // configure options
    this.configureOptions_(options);

    // verify module file
    moduleFile = this.moduleFile_ = _path.normalize(_path.resolve(moduleFile));
    if (!_fs.existsSync(moduleFile) || !_fs.statSync(moduleFile).isFile()) {
        throw new Error(_system.string.format("File '{0}' does not exist.", moduleFile));
    }
    this.moduleDirectory_ = _path.dirname(moduleFile);

    // watch for changes
    var self = this;
    this.moduleWatcher_ = _fs.watchFiles(moduleFile, function () {
        self.moduleChanged_();
    });
    this.moduleChanged_();
};

// inherit EventEmitter
_sys.inherits(ModuleWatcher, _events.EventEmitter);

_system.extend(ModuleWatcher.prototype,
    /**
     * @lends ModuleWatcher.prototype
     */
    {
        getModule:function () {
            return this.module_;
        },
        /**
         * Loads/Reloads the module
         * @param {Function} callback
         * @private
         */
        loadModule_:function (callback) {
            _fs.readFile(this.moduleFile_, function (err, data) {
                var module = null;
                if (!err) {
                    try {
                        module = _vm.runInThisContext(String(data));
                    }
                    catch (e) {
                        err = e;
                    }
                }
                callback(err, module);
            });
        },
        /**
         * Triggered when the module has been changed on disk.
         * @private
         */
        moduleChanged_:function () {
            if (this.isClosed()) {
                return;
            }

            var self = this;
            this.loadModule_(function (err, module) {
                self.module_ = module;
                self.updateCore_([self.moduleFile_]);
            });
        },
        /**
         * Triggered when one of the files that make up the module has been changed on disk.
         * @param fileName
         * @private
         */
        moduleFileChanged_:function (files) {
            if (!this.isClosed()) {
                this.updateCore_(files);
            }
        },
        /**
         * Triggered when either the module, or one of the files that make up the module has changed on disk.
         * @private
         */
        updateCore_:function (files) {
            if (!this.isClosed()) {
                // update watchers
                this.updateModuleFileWatchers_();

                // notify
                this.emit("changed", files);
            }
        },
        /**
         * Creates a callback that resolves the full path of the watched file
         * @param {Object} thisObject
         * @param {String} directory
         * @return {Function}
         */
        makeModuleFileWatcherCallback_:function (directory) {
            var self = this;
            return function (files) {
                self.moduleFileChanged_(files.map(function (file) {
                    return _path.normalize(_path.resolve(directory, file));
                }));
            }
        },
        /**
         * Update the watchers for the files that make up the module
         * @private
         */
        updateModuleFileWatchers_:function () {
            var newWatchers = {},
                oldWatchers = this.moduleFileWatchers_ || {};

            var files = this.module_ && this.module_.files;
            if (files) {
                files.forEach(function (file) {
                    var fileName = resolveFullPath(this.moduleDirectory_, file),
                        dirName = _path.dirname(fileName),
                        dirKey = getKeyForPath(dirName);

                    var watcher = newWatchers[dirKey];
                    if (!watcher) {
                        watcher = oldWatchers[dirKey];
                        if (!watcher) {
                            watcher = new _directory.Watcher(dirName);
                            watcher.on('changed',
                                this.makeModuleFileWatcherCallback_(dirName));
                        }
                        newWatchers[dirKey] = watcher;
                        watcher.watchFiles(
                            _path.basename(file));
                    }
                }, this);
            }

            // close any watchers no longer required
            Object.getOwnPropertyNames(oldWatchers).forEach(function (key) {
                if (!newWatchers.hasOwnProperty(key)) {
                    oldWatchers[key].close();
                }
            });

            this.moduleFileWatchers_ = newWatchers;
        },
        configureOptions_:function (value) {
            var options = this.options_ = {
                interval:defaultInterval
            };

            if (!_system.isNullOrUndefined(value)) {
                // read interval (instead of validating we will just take a save value, this MAY change)
                if (!_system.isNullOrUndefined(value.interval)) {
                    var interval = Number(value.interval);
                    options.interval = Math.max(minimumInterval,
                        isNaN(interval) ? defaultInterval : interval);
                }
            }
        },
        close:function () {
            // already closed
            if (this.isClosed_) {
                return;
            }
            this.isClosed_ = true;

            // close module watcher
            this.moduleWatcher_.close();
            this.moduleWatcher_ = null;

            // close all module file watchers
            var watchers = this.moduleFileWatchers_;
            if (watchers) {
                Object.getOwnPropertyNames(watchers).forEach(function (watcher) {
                    watcher.close();
                });

                this.moduleFileWatchers_ = null;
            }
        },
        isClosed:function () {
            return this.isClosed_;
        }
    });

module.exports = ModuleWatcher;






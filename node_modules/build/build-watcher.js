var _system = require('system'),
    _fs = require('fs'),
    _path = require('path'),
    _events = require('events'),
    _sys = require('sys'),
    _vm = require('vm');

var resolveFullPath = function (basePath, fileName) {
    return _path.normalize(_path.resolve(basePath, fileName));
};

var getKeyForPath = function (path) {
    // this is not really correct, but it should work for the majority of cases.
    return process.platform === 'win32' ? path.toLowerCase() : path;
}

var defaultInterval = 250,
    minimumInterval = 100;

var DirectoryWatcher = function (path) {
    _events.EventEmitter.call(this);
    this.watcher_ = null;
    this.path_ = path;
    this.fileInfo_ = {};
    this.fileInfoCount_ = 0;
    this.modifiedFileInfo_ = {};
};

_sys.inherits(DirectoryWatcher, _events.EventEmitter);

_system.extend(DirectoryWatcher.prototype,
    {
        getPath:function () {
            return this.path_;
        },
        addFiles:function (files) {
            this.throwIfClosed_();

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = getKeyForPath(file), fileInfo = this.fileInfo_[key];
                if (!fileInfo) {
                    fileInfo = {
                        name:file,
                        lastModified:new Date(),
                        exists:null
                    };
                    this.fileInfo_[key] = fileInfo;

                    // track count of files
                    this.fileInfoCount_++;
                }
            }, this);

            if (!this.watcher_ && this.fileInfoCount_) {
                var self = this;
                try {
                    this.watcher_ = _fs.watch(this.path_, function () {
                        // TODO: Optimize for when we DO get passed a filename!!
                        self.update_();
                    });
                } catch (e) {
                    // TODO: Support recursive update
                }
            }
        },
        removeFiles:function (files) {
            this.throwIfClosed_();

            files = Array.isArray(files) ? files : [files];
            files.forEach(function (file) {
                var key = getKeyForPath(file);
                if (this.hasOwnProperty(key)) {
                    delete this.fileInfo_[key];
                    delete this.modifiedFileInfo_[key];

                    this.fileInfoCount_--;
                }
            }, this);

            if (!this.fileInfoCount_) {
                this.closeWatcher_();
            }
        },
        getFiles:function () {
            return Object.getOwnPropertyNames(this.fileInfo_).map(
                function (propertyName) {
                    return this.fileInfo_[propertyName].name;
                },
                this);
        },
        close:function () {
            if (!this.isClosed_) {
                this.closeWatcher_();
                this.cancelUpdate_();
                this.fileInfo_ = null;
                this.fileInfoCount_ = 0;
                this.isClosed_ = true;
            }
        },
        update_:function () {
            if (!this.isUpdating_) {
                this.isUpdating_ = true;

                // throttle...
                var self = this;
                setTimeout(function () {
                    self.isUpdating = false;
                    self.updateCore_();
                }, defaultInterval);
            }
        },
        updateCore_:function () {
            var files = this.getFiles(), fileCount = files.length, self = this;

            // cancel any running update
            this.cancelUpdate_();

            // track completion
            function complete() {
                if (!cancellationToken.isCancelled && !--fileCount) {
                    self.emit('changed', Object.getOwnPropertyNames(self.modifiedFileInfo_).map(function (propertyName) {
                        return self.modifiedFileInfo_[propertyName].name;
                    }, self));
                }
            }

            // create a cancellation token
            var cancellationToken = this.updateToken_ = {
                isCancelled:false
            };

            // update status
            for (var i = 0, n = files.length; i < n && !cancellationToken.isCancelled; i++) {
                this.updateFile_(files[i], cancellationToken, complete);
            }
        },
        updateFile_:function (file, cancellationToken, callback) {
            var fullPath = _path.join(this.path_, file), self = this;
            _fs.stat(fullPath, function (err, stats) {
                if (!cancellationToken.isCancelled && !err) {
                    // get fileInfo, it may have been removed whilst getting info
                    var key = getKeyForPath(file), fileInfo = self.fileInfo_[key], lastModified = stats.mTime;

                    // check for modification
                    if (fileInfo && lastModified !== fileInfo.lastModified) {
                        fileInfo.lastModified = lastModified;

                        // record the file as modified
                        self.modifiedFileInfo_[key] = fileInfo;
                    }
                }

                // done
                callback();
            });
        },
        closeWatcher_:function () {
            if (this.watcher_) {
                this.watcher_.close();
                this.watcher_ = null;
            }
        },
        cancelUpdate_:function () {
            if (this.updateToken_) {
                this.updateToken_.isCancelled = true;
                this.updateToken_ = null;
            }
        },
        throwIfClosed_:function () {
            if (this.isClosed_) {
                throw new Error("Invalid operations, directory watcher has been closed.");
            }
        }
    });

var ModuleWatcher = function Watcher(moduleFile, options) {
    // initialize as event emitter
    _events.EventEmitter.call(this);

    // configure options
    this.configureOptions_(options);

    // verify module file
    moduleFile = this.moduleFile_ = _path.normalize(_path.resolve(moduleFile));
    if (!_fs.existsSync(moduleFile) || !_fs.statSync(moduleFile).isFile()) {
        throw new Error(_system.string.format("File '{0}' does not exist.", moduleFile));
    }
    this.moduleDirectory_ = _path.dirname(moduleFile);

    // watch for changes
    var self = this;
    this.moduleWatcher_ = _fs.watch(moduleFile, function () {
        self.moduleChanged_();
    });
    this.moduleChanged_();
};

// inherit EventEmitter
_sys.inherits(ModuleWatcher, _events.EventEmitter);

_system.extend(ModuleWatcher.prototype,
    /**
     * @extends ModuleWatcher.prototype
     */
    {
        getModule:function () {
            return this.module_;
        },
        /**
         * Loads/Reloads the module
         * @param {Function} callback
         * @private
         */
        loadModule_:function (callback) {
            _fs.readFile(this.moduleFile_, function (err, data) {
                var module = null;
                if (!err) {
                    try {
                        module = _vm.runInThisContext(String(data));
                    }
                    catch (e) {
                        err = e;
                    }
                }
                callback(err, module);
            });
        },
        /**
         * Triggered when the module has been changed on disk.
         * @private
         */
        moduleChanged_:function () {
            if (this.isClosed()) {
                return;
            }

            var self = this;
            this.loadModule_(function (err, module) {
                self.module_ = module;
                self.updateCore_([self.moduleFile_]);
            });
        },
        /**
         * Triggered when one of the files that make up the module has been changed on disk.
         * @param fileName
         * @private
         */
        moduleFileChanged_:function (files) {
            if (!this.isClosed()) {
                this.updateCore_(files);
            }
        },
        /**
         * Triggered when either the module, or one of the files that make up the module has changed on disk.
         * @private
         */
        updateCore_:function (files) {
            if (!this.isClosed()) {
                // update watchers
                this.updateModuleFileWatchers_();

                // notify
                this.emit("changed", files);
            }
        },
        /**
         * Creates a callback that resolves the full path of the watched file
         * @param {Object} thisObject
         * @param {String} directory
         * @return {Function}
         */
        makeModuleFileWatcherCallback_:function (directory) {
            var self = this;
            return function (files) {
                self.moduleFileChanged_(files.map(function (file) {
                    return _path.normalize(_path.resolve(directory, file));
                }));
            }
        },
        /**
         * Update the watchers for the files that make up the module
         * @private
         */
        updateModuleFileWatchers_:function () {
            var newWatchers = {},
                oldWatchers = this.moduleFileWatchers_ || {};

            var files = this.module_ && this.module_.files;
            if (files) {
                files.forEach(function (file) {
                    var fileName = resolveFullPath(this.moduleDirectory_, file),
                        dirName = _path.dirname(fileName),
                        dirKey = getKeyForPath(dirName);

                    var watcher = newWatchers[dirKey];
                    if (!watcher) {
                        watcher = oldWatchers[dirKey];
                        if (!watcher) {
                            watcher = new DirectoryWatcher(dirName);
                            watcher.on('changed',
                                this.makeModuleFileWatcherCallback_(dirName));
                        }
                        newWatchers[dirKey] = watcher;
                        watcher.addFiles(
                            _path.basename(file));
                    }
                }, this);
            }

            // close any watchers no longer required
            Object.getOwnPropertyNames(oldWatchers).forEach(function (key) {
                if (!newWatchers.hasOwnProperty(key)) {
                    oldWatchers[key].close();
                }
            });

            this.moduleFileWatchers_ = newWatchers;
        },
        configureOptions_:function (value) {
            var options = this.options_ = {
                interval:defaultInterval
            };

            if (!_system.isNullOrUndefined(value)) {
                // read interval (instead of validating we will just take a save value, this MAY change)
                if (!_system.isNullOrUndefined(value.interval)) {
                    var interval = Number(value.interval);
                    options.interval = Math.max(minimumInterval,
                        isNaN(interval) ? defaultInterval : interval);
                }
            }
        },
        close:function () {
            // already closed
            if (this.isClosed_) {
                return;
            }
            this.isClosed_ = true;

            // close module watcher
            this.moduleWatcher_.close();
            this.moduleWatcher_ = null;

            // close all module file watchers
            var watchers = this.moduleFileWatchers_;
            if (watchers) {
                Object.getOwnPropertyNames(watchers).forEach(function (watcher) {
                    watcher.close();
                });

                this.moduleFileWatchers_ = null;
            }
        },
        isClosed:function () {
            return this.isClosed_;
        }
    });

module.exports = ModuleWatcher;





